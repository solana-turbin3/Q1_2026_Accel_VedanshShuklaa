basically what I'm building is a transfer fee extension based token 2022 style token, the workflow of this is first we init the token, then we make the treasury, and then we have lets say 2 users alice and bob, they transfer tokens to each other, and the fees accumulate, those fees are periodically harvested and withdrawn by a tuktuk worker and stored in our treasury, that's the gist of what I'm trying to do with this. What I want you to do is find any flaws in the files I've supplied you, correct them, and then write proper tests and setup files for them, at the very end I'll give you examples of how others set cron jobs up, I don't want to test everything, just a simple accumulate transfer fees and then finally through the help of our scheduler we collect them (No manual collect)

InitMint.rs

use anchor_lang::prelude::*;
use anchor_lang::system_program::{create_account, CreateAccount};
use anchor_spl::{
    token_2022::{
        initialize_mint2,
        spl_token_2022::{
            extension::{
                transfer_fee::TransferFeeConfig, BaseStateWithExtensions, ExtensionType,
                StateWithExtensions,
            },
            pod::PodMint,
            state::Mint as MintState,
        },
        InitializeMint2,
    },
    token_interface::{
        spl_pod::optional_keys::OptionalNonZeroPubkey, transfer_fee_initialize, Token2022,
        TransferFeeInitialize,
    },
};

#[derive(Accounts)]
pub struct InitMint<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    pub mint: Signer<'info>,

    pub token_program: Program<'info, Token2022>,

    pub system_program: Program<'info, System>,
}

pub fn process_init_mint(
    ctx: Context<InitMint>,
    transfer_fee_basis_points: u16,
    maximum_fee: u64,
) -> Result<()> {
    // Calculate space required for mint and extension data
    let mint_size =
        ExtensionType::try_calculate_account_len::<PodMint>(&[ExtensionType::TransferFeeConfig])?;

    // Calculate minimum lamports required for size of mint account with extensions
    let lamports = (Rent::get()?).minimum_balance(mint_size);

    // Invoke System Program to create new account with space for mint and extension data
    create_account(
        CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            CreateAccount {
                from: ctx.accounts.authority.to_account_info(),
                to: ctx.accounts.mint.to_account_info(),
            },
        ),
        lamports,                          // Lamports
        mint_size as u64,                  // Space
        &ctx.accounts.token_program.key(), // Owner Program
    )?;

    // Initialize the transfer fee extension data
    // This instruction must come before the instruction to initialize the mint data
    transfer_fee_initialize(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferFeeInitialize {
                token_program_id: ctx.accounts.token_program.to_account_info(),
                mint: ctx.accounts.mint.to_account_info(),
            },
        ),
        Some(&ctx.accounts.authority.key()), // transfer fee config authority (update fee)
        Some(&ctx.accounts.authority.key()), // withdraw authority (withdraw fees)
        transfer_fee_basis_points,       // transfer fee basis points (% fee per transfer)
        maximum_fee,                     // maximum fee (maximum units of token per transfer)
    )?;

    // Initialize the standard mint account data
    initialize_mint2(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            InitializeMint2 {
                mint: ctx.accounts.mint.to_account_info(),
            },
        ),
        2,                               // decimals
        &ctx.accounts.authority.key(),       // mint authority
        Some(&ctx.accounts.authority.key()), // freeze authority
    )?;

    ctx.accounts.init_mint()?;
    Ok(())
}

impl<'info> InitMint<'info> {
    pub fn init_mint(&mut self) -> Result<()> {

        let mint = &self.mint.to_account_info();
        let mint_data = mint.data.borrow();
        let mint_with_extension = StateWithExtensions::<MintState>::unpack(&mint_data)?;
        let extension_data = mint_with_extension.get_extension::<TransferFeeConfig>()?;
        
        assert_eq!(
            extension_data.transfer_fee_config_authority,
            OptionalNonZeroPubkey::try_from(Some(self.authority.key()))?
        );

        assert_eq!(
            extension_data.withdraw_withheld_authority,
            OptionalNonZeroPubkey::try_from(Some(self.authority.key()))?
        );

        msg!("{:?}", extension_data);

        Ok(())
    }
}

InitTreasury.rs

use anchor_lang::prelude::*;
use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};
use anchor_spl::associated_token::AssociatedToken;

#[derive(Accounts)]
pub struct InitTreasury<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        associated_token::mint = mint,
        associated_token::authority = authority,
        associated_token::token_program = token_program, // required for token-2022 compatibility
    )]
    pub treasury: InterfaceAccount<'info, TokenAccount>,

    pub mint: InterfaceAccount<'info, Mint>,

    // Use Interface<..., TokenInterface> when you use InterfaceAccount above
    pub token_program: Interface<'info, TokenInterface>,

    pub associated_token_program: Program<'info, AssociatedToken>,

    pub system_program: Program<'info, System>,
}

impl<'info> InitTreasury<'info> {
    pub fn init_treasury(&self) -> Result<()> {
        Ok(())
    }
}

Manual Collect.rs

use anchor_lang::prelude::*;
use anchor_spl::token_interface::{
    harvest_withheld_tokens_to_mint, HarvestWithheldTokensToMint, withdraw_withheld_tokens_from_mint, Mint, TokenInterface, TokenAccount,
    WithdrawWithheldTokensFromMint,
};

#[derive(Accounts)]
pub struct ManualCollect<'info> {
    pub authority: Signer<'info>,

    #[account(mut)]
    pub mint_account: InterfaceAccount<'info, Mint>,

    #[account(mut)]
    pub treasury_token_account: InterfaceAccount<'info, TokenAccount>,

    // must be Interface when using InterfaceAccount
    pub token_program: Interface<'info, TokenInterface>,

    pub system_program: Program<'info, System>,
}

pub fn collect<'info>(ctx: Context<'_, '_, 'info, 'info, ManualCollect<'info>>) -> Result<()> {
    // Using remaining accounts to allow for passing in an unknown number of token accounts to harvest from
    // Check that remaining accounts are token accounts for the mint to harvest to
    let sources = ctx
        .remaining_accounts
        .iter()
        .filter_map(|account| {
            InterfaceAccount::<TokenAccount>::try_from(account)
                .ok()
                .filter(|token_account| token_account.mint == ctx.accounts.mint_account.key())
                .map(|_| account.to_account_info())
        })
        .collect::<Vec<_>>();
    
    harvest_withheld_tokens_to_mint(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            HarvestWithheldTokensToMint {
                token_program_id: ctx.accounts.token_program.to_account_info(),
                mint: ctx.accounts.mint_account.to_account_info(),
            },
        ),
        sources, // token accounts to harvest from
    )?;

    withdraw_withheld_tokens_from_mint(CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        WithdrawWithheldTokensFromMint {
            token_program_id: ctx.accounts.token_program.to_account_info(),
            mint: ctx.accounts.mint_account.to_account_info(),
            destination: ctx.accounts.treasury_token_account.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
        },
    ))?;
    Ok(())
}

Schedule.rs

use std::str::FromStr;

use anchor_lang::{prelude::*, InstructionData};
use anchor_lang::solana_program::instruction::Instruction;
use anchor_spl::token_interface::Token2022;
use tuktuk_program::{
    TransactionSourceV0, 
    compile_transaction, 
    tuktuk::{
        cpi::{
            accounts::{
                QueueTaskV0, 
                InitializeTaskQueueV0
            },
            queue_task_v0, 
            initialize_task_queue_v0
        }, 
        program::Tuktuk, 
        types::TriggerV0
    }, types::QueueTaskArgsV0
};


#[derive(Accounts)]
pub struct Schedule<'info> {
    #[account(
        mut,
        address = Pubkey::from_str("AHYic562KhgtAEkb1rSesqS87dFYRcfXb4WwWus3Zc9C").unwrap()
    )]
    pub user: Signer<'info>,

    #[account(mut)]
    /// CHECK: Don't need to parse this account, just using it in CPI
    pub task_queue: UncheckedAccount<'info>,
    /// CHECK: Don't need to parse this account, just using it in CPI
    pub task_queue_authority: UncheckedAccount<'info>,
    /// CHECK: Initialized in CPI
    #[account(mut)]
    pub task: UncheckedAccount<'info>,
    /// CHECK: Via seeds
    #[account(
        mut,
        seeds = [b"queue_authority"],
        bump
    )]
    pub queue_authority: AccountInfo<'info>,
    /// CHECK: Mint account validated in CPI call to manual_collect
    pub mint_account: AccountInfo<'info>,
    /// CHECK: Treasury token account validated in CPI call to manual_collect
    pub treasury_token_account: AccountInfo<'info>,
    pub token_program: Program<'info, Token2022>,
    pub system_program: Program<'info, System>,
    pub tuktuk_program: Program<'info, Tuktuk>
}

impl<'info> Schedule<'info> {
    pub fn schedule(&self, task_id: u16, bumps: ScheduleBumps) -> Result<()> {

        let (compiled_tx, _) = compile_transaction(
            vec![Instruction {
                program_id: crate::ID,
                accounts: crate:: __cpi_client_accounts_manual_collect::ManualCollect {
                    authority: self.user.to_account_info(),
                    mint_account: self.mint_account.to_account_info(),
                    treasury_token_account: self.treasury_token_account.to_account_info(),
                    token_program: self.token_program.to_account_info(),
                    system_program: self.system_program.to_account_info(),
                }
                .to_account_metas(None)
                .to_vec(),
                data: crate::instruction::ManualCollect {}.data(),
            }],
        vec![],
        ).unwrap();

        queue_task_v0(
            CpiContext::new_with_signer(
                self.tuktuk_program.to_account_info(),
                QueueTaskV0 {
                    payer: self.user.to_account_info(),
                    queue_authority: self.queue_authority.to_account_info(),
                    task_queue: self.task_queue.to_account_info(),
                    task_queue_authority: self.task_queue_authority.to_account_info(),
                    task: self.task.to_account_info(),
                    system_program: self.system_program.to_account_info(),
                },
                &[&["queue_authority".as_bytes(), &[bumps.queue_authority]]],
            ),
            QueueTaskArgsV0 {
                trigger: TriggerV0::Now,
                transaction: TransactionSourceV0::CompiledV0(compiled_tx),
                crank_reward: Some(1000001),
                free_tasks: 1,
                id: task_id,
                description: "test".to_string(),
            },
        ).unwrap();

        Ok(())
    }
}

Transfer.rs

use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_2022::spl_token_2022::{
        extension::{
            transfer_fee::TransferFeeConfig, BaseStateWithExtensions, StateWithExtensions,
        },
        state::Mint as MintState,
    },
    token_interface::{
        transfer_checked_with_fee, Mint, Token2022, TokenAccount, TransferCheckedWithFee,
    },
};

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    pub sender: Signer<'info>,
    pub recipient: SystemAccount<'info>,

    #[account(mut)]
    pub mint_account: InterfaceAccount<'info, Mint>,
    #[account(
        mut,
        associated_token::mint = mint_account,
        associated_token::authority = sender,
        associated_token::token_program = token_program
    )]
    pub sender_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(
        init_if_needed,
        payer = sender,
        associated_token::mint = mint_account,
        associated_token::authority = recipient,
        associated_token::token_program = token_program
    )]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Program<'info, Token2022>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}

// transfer fees are automatically deducted from the transfer amount
// recipients receives (transfer amount - fees)
// transfer fees are stored directly on the recipient token account and must be "harvested"
pub fn process_transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
    // read mint account extension data
    let mint = &ctx.accounts.mint_account.to_account_info();
    let mint_data = mint.data.borrow();
    let mint_with_extension = StateWithExtensions::<MintState>::unpack(&mint_data)?;
    let extension_data = mint_with_extension.get_extension::<TransferFeeConfig>()?;

    // calculate expected fee
    let epoch = Clock::get()?.epoch;
    let fee = extension_data.calculate_epoch_fee(epoch, amount).unwrap();

    // mint account decimals
    let decimals = ctx.accounts.mint_account.decimals;

    transfer_checked_with_fee(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferCheckedWithFee {
                token_program_id: ctx.accounts.token_program.to_account_info(),
                source: ctx.accounts.sender_token_account.to_account_info(),
                mint: ctx.accounts.mint_account.to_account_info(),
                destination: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.sender.to_account_info(),
            },
        ),
        amount,   // transfer amount
        decimals, // decimals
        fee,      // fee
    )?;

    msg!("transfer amount {}", amount);
    msg!("fee amount {}", fee);

    Ok(())
}

update_fee.rs ( no need to test this)

use anchor_lang::prelude::*;
use anchor_spl::token_interface::{transfer_fee_set, Mint, Token2022, TransferFeeSetTransferFee};

#[derive(Accounts)]
pub struct UpdateFee<'info> {
    pub authority: Signer<'info>,

    #[account(mut)]
    pub mint_account: InterfaceAccount<'info, Mint>,
    pub token_program: Program<'info, Token2022>,
}

// Note that there is a 2 epoch delay from when new fee updates take effect
// This is a safely feature built into the extension
// https://github.com/solana-labs/solana-program-library/blob/master/token/program-2022/src/extension/transfer_fee/processor.rs#L92-L109
pub fn process_update_fee(
    ctx: Context<UpdateFee>,
    transfer_fee_basis_points: u16,
    maximum_fee: u64,
) -> Result<()> {
    transfer_fee_set(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferFeeSetTransferFee {
                token_program_id: ctx.accounts.token_program.to_account_info(),
                mint: ctx.accounts.mint_account.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        ),
        transfer_fee_basis_points, // transfer fee basis points (% fee per transfer)
        maximum_fee,               // maximum fee (maximum units of token per transfer)
    )?;
    Ok(())
}

finally the lib.rs

use anchor_lang::prelude::*;

declare_id!("8UySKpt3x9RWzR8WRAPQsgtVtovLwe8DygxCo7irvkGR");

mod state;
mod instructions;
mod error;

use instructions::*;

#[program]
pub mod automated_fee_collector {
    use super::*;

    pub fn init_mint(ctx: Context<InitMint>, transfer_fee_basis_points: u16, maximum_fee: u64) -> Result<()> {
        process_init_mint(ctx, transfer_fee_basis_points, maximum_fee)
    }

    pub fn init_treasury(ctx: Context<InitTreasury>) -> Result<()> {
        ctx.accounts.init_treasury()
    }

    pub fn manual_collect<'info>(ctx: Context<'_, '_, 'info, 'info, ManualCollect<'info>>) -> Result<()> {
        collect(ctx)
    }

    pub fn update_fee(ctx: Context<UpdateFee>, transfer_fee_basis_points: u16, maximum_fee: u64) -> Result<()> {
        process_update_fee(ctx, transfer_fee_basis_points, maximum_fee)
    }

    pub fn schedule(ctx: Context<Schedule>, task_id: u16) -> Result<()> {
        ctx.accounts.schedule(task_id, ctx.bumps)
    }

    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
        process_transfer(ctx, amount)
    }
}

example of someone setting this up and testing it on their program

cron/cron.ts

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { createCronJob, 
    cronJobTransactionKey, 
    getCronJobForName, 
    init as initCron 
} from "@helium/cron-sdk";
import {
  compileTransaction,
  init,
  taskQueueAuthorityKey
} from "@helium/tuktuk-sdk";
import { 
    LAMPORTS_PER_SOL, 
    SystemProgram, 
    TransactionInstruction 
} from "@solana/web3.js";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { sendInstructions } from "@helium/spl-utils";
import { TuktukCounter } from "../target/types/tuktuk_counter";


const counterProgram = anchor.workspace.tuktukCounter as Program<TuktukCounter>;

const counter = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from("counter")], counterProgram.programId)[0];

async function main() {
    const argv = await yargs(hideBin(process.argv))
        .options({
        cronName: {
            type: "string",
            description: "The name of the cron job to create",
            demandOption: true,
        },
        queueName: {
            type: "string",
            description: "The name of the task queue to use",
            demandOption: true,
        },
        walletPath: {
            type: "string",
            description: "Path to the wallet keypair",
            demandOption: true,
        },
        rpcUrl: {
            type: "string",
            description: "Your Solana RPC URL",
            demandOption: true,
        },
        message: {
            type: "string",
            description: "Message to write in the memo",
            default: "This will create a cron job for the Turbin3 Accel tuktuk counter program!",
        },
        fundingAmount: {
            type: "number",
            description: "Amount of SOL to fund the cron job with (in lamports)",
            default: 0.01 * LAMPORTS_PER_SOL,
        },
        })
        .help()
        .alias("help", "h").argv;

    // Setup connection and provider
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);
    const wallet = provider.wallet as anchor.Wallet;

    console.log("Using wallet:", wallet.publicKey.toBase58());
    console.log("RPC URL:", argv.rpcUrl);
    console.log("Message:", argv.message);

    // Initialize TukTuk program
    const program = await init(provider);
    const cronProgram = await initCron(provider);
    const taskQueue = new anchor.web3.PublicKey("CMreFdKxT5oeZhiX8nWTGz9PtXM1AMYTh6dGR2UzdtrA");

    // Check if task_queue_authority exists for this wallet, if not create it
    const taskQueueAuthorityPda = taskQueueAuthorityKey(taskQueue, wallet.publicKey)[0];
    const taskQueueAuthorityInfo = await provider.connection.getAccountInfo(taskQueueAuthorityPda);
    
    if (!taskQueueAuthorityInfo) {
        console.log("Initializing task queue authority for wallet...");
        await program.methods
            .addQueueAuthorityV0()
            .accounts({
                payer: wallet.publicKey,
                queueAuthority: wallet.publicKey,
                taskQueue,
            })
            .rpc({ skipPreflight: true });
        console.log("Task queue authority initialized!");
    } else {
        console.log("Task queue authority already exists");
    }

    // Check if cron job already exists
    let cronJob = await getCronJobForName(cronProgram, argv.cronName);
    console.log("Cron Job:", cronJob);
    if (!cronJob) {
        console.log("Creating new cron job...");
        const { pubkeys: { cronJob: cronJobPubkey } } = await (await createCronJob(cronProgram, {
            tuktukProgram: program,
            taskQueue,
            args: {
                name: argv.cronName,
                schedule: "0 * * * * *", // Run every minute
                // How many "free" tasks to allocate to this cron job per transaction (whitout paying crank fee)
                // The increment transaction doesn't need to schedule more transactions, so we set this to 0
                freeTasksPerTransaction: 0,
                // We just have one transaction to queue for each cron job, so we set this to 1
                numTasksPerQueueCall: 1,
            }
        }))
        .rpcAndKeys({ skipPreflight: false });
        cronJob = cronJobPubkey;
        console.log("Funding cron job with", argv.fundingAmount / LAMPORTS_PER_SOL, "SOL");
        await sendInstructions(provider, [
        SystemProgram.transfer({
            fromPubkey: provider.publicKey,
            toPubkey: cronJob,
            lamports: argv.fundingAmount,
        }),
        ]);
        // Create a simple increment instruction
        const counterInstruction = new TransactionInstruction({
            keys: [
                { pubkey: counter, isSigner: false, isWritable: true }
            ],
            data: counterProgram.coder.instruction.encode("increment", {}),
            programId: counterProgram.programId,
        });

        // Compile the instruction
        console.log("Compiling instructions...");
        const { transaction, remainingAccounts } = compileTransaction(
            [counterInstruction],
            []
        );

        // Adding increment to the cron job
        await cronProgram.methods
        .addCronTransactionV0({
            index: 0,
            transactionSource: {
            compiledV0: [transaction],
            },
        })
        .accounts({
            payer: provider.publicKey,
            cronJob,
            cronJobTransaction: cronJobTransactionKey(cronJob, 0)[0],
        })
        .remainingAccounts(remainingAccounts)
        .rpc({ skipPreflight: true });
        console.log(`Cron job created!`);
    } else {
        console.log("Cron job already exists");
    }

    console.log("Cron job address:", cronJob.toBase58());
    console.log(`\nYour Counter Increment Instruction will be posted every minute. Watch for transactions on task queue ${taskQueue.toBase58()}. To stop the cron job, use the tuktuk-cli:`);
    console.log(`tuktuk -u ${argv.rpcUrl} -w ${argv.walletPath} cron-transaction close --cron-name ${argv.cronName} --id 0`);
    console.log(`tuktuk -u ${argv.rpcUrl} -w ${argv.walletPath} cron close --cron-name ${argv.cronName}`);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  }); 

tests/tuktuk-counter.ts

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  init,
  taskKey,
  taskQueueAuthorityKey,
} from "@helium/tuktuk-sdk";
import { TuktukCounter } from "../target/types/tuktuk_counter";
import { assert } from "chai";

describe("tuktuk-counter", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env()
  anchor.setProvider(provider);

  const program = anchor.workspace.tuktukCounter as Program<TuktukCounter>;

  const taskQueue = new anchor.web3.PublicKey("CMreFdKxT5oeZhiX8nWTGz9PtXM1AMYTh6dGR2UzdtrA");
  const counter = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from("counter")], program.programId)[0];
  const queueAuthority = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from("queue_authority")], program.programId)[0];
  const taskQueueAuthority = taskQueueAuthorityKey(taskQueue, queueAuthority)[0];

  xit("Initialize counter", async () => {
    const tx = await program.methods.initialize()
    .accountsPartial({
      user: provider.publicKey,
      counter: counter,
      systemProgram: anchor.web3.SystemProgram.programId,
    })
    .rpc();
    console.log("\nYour transaction signature", tx);
  });

  it("Increment counter", async () => {
    const tx = await program.methods.increment()
    .accountsPartial({
      counter: counter,
    })
    .rpc();
    console.log("\nYour transaction signature", tx);
    console.log("\nQueue Authority PDA:", queueAuthority.toBase58());
    console.log("\nCounter Value:", (await program.account.counter.fetch(counter)).count.toString());
  });

  it("Schedule increment task", async () => {
    let tuktukProgram = await init(provider);

    let taskID = 6;
    const tx = await program.methods.schedule(taskID)
    .accountsPartial({
      user: provider.publicKey,
      counter: counter,
      taskQueue: taskQueue,
      taskQueueAuthority: taskQueueAuthority,
      task: taskKey(taskQueue, taskID)[0],
      queueAuthority: queueAuthority,
      systemProgram: anchor.web3.SystemProgram.programId,
      tuktukProgram: tuktukProgram.programId,
    })
    .rpc({skipPreflight: true});
    assert(tuktukProgram.programId.equals(new anchor.web3.PublicKey("tuktukUrfhXT6ZT77QTU8RQtvgL967uRuVagWF57zVA")));
    console.log("\nYour transaction signature", tx);
  });
});

use std::str::FromStr;

use anchor_lang::{prelude::*, InstructionData};
use anchor_lang::solana_program::instruction::Instruction;
use tuktuk_program::{
    TransactionSourceV0, 
    compile_transaction, 
    tuktuk::{
        cpi::{
            accounts::{
                QueueTaskV0, 
                InitializeTaskQueueV0
            },
            queue_task_v0, 
            initialize_task_queue_v0
        }, 
        program::Tuktuk, 
        types::TriggerV0
    }, types::QueueTaskArgsV0
};

use crate::state::Counter;

#[derive(Accounts)]
pub struct Schedule<'info> {
    #[account(
        mut,
        address = Pubkey::from_str("AHYic562KhgtAEkb1rSesqS87dFYRcfXb4WwWus3Zc9C").unwrap()
    )]
    pub user: Signer<'info>,
    /// CHECK: This is safe because we don't read or write from this account
    #[account(
        mut,
        seeds = [b"counter"],
        bump,
    )]
    pub counter: Account<'info, Counter>,
    #[account(mut)]
    /// CHECK: Don't need to parse this account, just using it in CPI
    pub task_queue: UncheckedAccount<'info>,
    /// CHECK: Don't need to parse this account, just using it in CPI
    pub task_queue_authority: UncheckedAccount<'info>,
    /// CHECK: Initialized in CPI
    #[account(mut)]
    pub task: UncheckedAccount<'info>,
    /// CHECK: Via seeds
    #[account(
        mut,
        seeds = [b"queue_authority"],
        bump
    )]
    pub queue_authority: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub tuktuk_program: Program<'info, Tuktuk>,
}

impl<'info> Schedule<'info> {
    pub fn schedule(&mut self, task_id: u16, bumps: ScheduleBumps) -> Result<()> {
        let (compiled_tx, _) = compile_transaction(
            vec![Instruction {
                program_id: crate::ID,
                accounts: crate::__cpi_client_accounts_increment::Increment {
                    counter: self.counter.to_account_info(),
                }
                .to_account_metas(None)
                .to_vec(),
                data: crate::instruction::Increment {}.data(),
            }],
        vec![],
        ).unwrap();

        queue_task_v0(
            CpiContext::new_with_signer(
                self.tuktuk_program.to_account_info(),
                QueueTaskV0 {
                    payer: self.user.to_account_info(),
                    queue_authority: self.queue_authority.to_account_info(),
                    task_queue: self.task_queue.to_account_info(),
                    task_queue_authority: self.task_queue_authority.to_account_info(),
                    task: self.task.to_account_info(),
                    system_program: self.system_program.to_account_info(),
                },
                &[&["queue_authority".as_bytes(), &[bumps.queue_authority]]],
            ),
            QueueTaskArgsV0 {
                trigger: TriggerV0::Now,
                transaction: TransactionSourceV0::CompiledV0(compiled_tx),
                crank_reward: Some(1000001),
                free_tasks: 1,
                id: task_id,
                description: "test".to_string(),
            },
        )?;
        
    Ok(())
    }
}

and this is their schedule program